# -*- coding: utf-8 -*-
"""
Hybrid UI Automation Script - 互動設定介面
提供使用者友善的設定介面，讓使用者選擇多輪互動的相關設定
"""

import tkinter as tk
from tkinter import ttk, messagebox
import json
import sys
from pathlib import Path

# 設定模組搜尋路徑
sys.path.append(str(Path(__file__).parent.parent))
from config.config import config

class InteractionSettingsUI:
    """多輪互動設定介面"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Copilot Chat 多輪互動設定")
        self.root.geometry("600x500")  # 增大視窗尺寸
        self.root.resizable(False, False)
        
        # 設定關閉事件處理
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)
        self.cancelled = False  # 追蹤是否被取消
        
        # 載入現有設定
        self.settings = self.load_settings()
        
        # 建立 UI
        self.create_widgets()
        
    def load_settings(self):
        """載入設定檔案"""
        # 導入設定管理器
        from src.settings_manager import settings_manager
        
        interaction_settings = settings_manager.get_interaction_settings()
        automation_settings = settings_manager.load_settings().get("settings", {}).get("automation", {})
        
        # 轉換為 UI 期望的格式
        return {
            "interaction_enabled": interaction_settings.get("enabled", config.INTERACTION_ENABLED),
            "max_rounds": interaction_settings.get("max_rounds", config.INTERACTION_MAX_ROUNDS),
            "include_previous_response": interaction_settings.get("include_previous_response", config.INTERACTION_INCLUDE_PREVIOUS_RESPONSE),
            "round_delay": interaction_settings.get("round_delay", config.INTERACTION_ROUND_DELAY),
            "batch_size": automation_settings.get("batch_size", config.BATCH_SIZE)
        }
    
    def save_settings(self):
        """儲存設定到檔案"""
        try:
            # 導入設定管理器
            from src.settings_manager import settings_manager
            
            # 更新互動設定
            interaction_settings = {
                "enabled": self.settings["interaction_enabled"],
                "max_rounds": self.settings["max_rounds"],
                "include_previous_response": self.settings["include_previous_response"],
                "round_delay": self.settings["round_delay"],
                "show_ui_on_startup": True
            }
            
            # 更新自動化設定
            full_settings = settings_manager.load_settings()
            if "settings" not in full_settings:
                full_settings["settings"] = {}
            if "automation" not in full_settings["settings"]:
                full_settings["settings"]["automation"] = {}
            
            full_settings["settings"]["automation"]["batch_size"] = self.settings["batch_size"]
            full_settings["settings"]["interaction"] = interaction_settings
            
            return settings_manager.save_settings(full_settings)
        except Exception as e:
            print(f"儲存設定時發生錯誤: {e}")
            return False
    
    def create_widgets(self):
        """建立 UI 元件"""
        # 主標題
        title_label = tk.Label(
            self.root, 
            text="選擇多輪互動模式", 
            font=("Arial", 16, "bold")
        )
        title_label.pack(pady=15)
        
        # 副標題
        subtitle_label = tk.Label(
            self.root, 
            text="請選擇本次執行的互動設定", 
            font=("Arial", 10),
            fg="gray"
        )
        subtitle_label.pack(pady=(0, 15))
        
        # 主要設定框架
        main_frame = ttk.Frame(self.root)
        main_frame.pack(padx=20, pady=10, fill="both", expand=True)
        
        # 啟用多輪互動
        self.interaction_enabled_var = tk.BooleanVar(
            value=self.settings["interaction_enabled"]
        )
        interaction_checkbox = ttk.Checkbutton(
            main_frame,
            text="啟用多輪互動功能",
            variable=self.interaction_enabled_var,
            command=self.on_interaction_enabled_changed
        )
        interaction_checkbox.pack(anchor="w", pady=5)
        
        # 互動設定框架
        self.interaction_frame = ttk.LabelFrame(main_frame, text="互動設定")
        self.interaction_frame.pack(fill="x", pady=10)
        
        # 最大輪數設定
        rounds_frame = ttk.Frame(self.interaction_frame)
        rounds_frame.pack(fill="x", padx=10, pady=5)
        
        ttk.Label(rounds_frame, text="最大互動輪數:").pack(side="left")
        self.max_rounds_var = tk.IntVar(value=self.settings["max_rounds"])
        rounds_spinbox = ttk.Spinbox(
            rounds_frame,
            from_=1,
            to=10,
            textvariable=self.max_rounds_var,
            width=5
        )
        rounds_spinbox.pack(side="right")
        
        # 批次大小設定
        batch_frame = ttk.Frame(self.interaction_frame)
        batch_frame.pack(fill="x", padx=10, pady=5)
        
        ttk.Label(batch_frame, text="每批處理專案數量:").pack(side="left")
        self.batch_size_var = tk.IntVar(value=self.settings["batch_size"])
        batch_spinbox = ttk.Spinbox(
            batch_frame,
            from_=1,
            to=1000,
            textvariable=self.batch_size_var,
            width=8
        )
        batch_spinbox.pack(side="right")
        
        # 回應串接設定框架
        chaining_frame = ttk.LabelFrame(main_frame, text="回應串接設定")
        chaining_frame.pack(fill="x", pady=10)
        
        # 啟用回應串接
        self.include_previous_var = tk.BooleanVar(
            value=self.settings["include_previous_response"]
        )
        chaining_checkbox = ttk.Checkbutton(
            chaining_frame,
            text="在新一輪提示詞中包含上一輪 Copilot 回應",
            variable=self.include_previous_var
        )
        chaining_checkbox.pack(anchor="w", padx=10, pady=5)
        
        # 說明文字
        explanation_text = tk.Text(
            chaining_frame,
            height=5,  # 增加高度
            width=60,  # 增加寬度
            wrap="word",
            state="disabled",
            bg=self.root.cget("bg"),
            font=("Arial", 9)  # 設定字體
        )
        explanation_text.pack(padx=10, pady=5, fill="x")
        
        explanation_content = """說明：
• 啟用時：每一輪會將上一輪的 Copilot 回應內容加入新的提示詞中，形成連續對話
• 停用時：每一輪都只使用原始的 prompt.txt 內容，進行獨立分析
• 建議在需要連續對話脈絡時啟用，單純重複分析時停用
• 批次大小：控制每次執行腳本時同時處理的專案數量，建議設為適當值避免過載
• 此設定僅適用於本次執行，下次執行時會再次詢問
• 輪次間會自動使用預設間隔時間"""
        
        explanation_text.config(state="normal")
        explanation_text.insert("1.0", explanation_content)
        explanation_text.config(state="disabled")
        
        # 按鈕框架
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill="x", pady=30)  # 增加 padding
        
        # 重設按鈕
        reset_button = ttk.Button(
            button_frame,
            text="重設為預設值",
            command=self.reset_to_defaults,
            width=15
        )
        reset_button.pack(side="left", padx=10)
        
        # 取消按鈕
        cancel_button = ttk.Button(
            button_frame,
            text="取消",
            command=self.on_close,  # 使用相同的關閉處理
            width=10
        )
        cancel_button.pack(side="right", padx=10)
        
        # 儲存按鈕
        save_button = ttk.Button(
            button_frame,
            text="確定執行",
            command=self.save_and_close,
            width=12
        )
        save_button.pack(side="right", padx=5)
        
        # 初始狀態設定
        self.on_interaction_enabled_changed()
    
    def on_close(self):
        """處理視窗關閉事件"""
        # 直接結束腳本，不再詢問
        print("使用者關閉設定視窗，結束腳本執行")
        self.cancelled = True
        self.root.destroy()
        sys.exit(0)  # 直接終止整個腳本
    
    def on_interaction_enabled_changed(self):
        """當啟用多輪互動選項改變時"""
        enabled = self.interaction_enabled_var.get()
        
        # 啟用或停用相關元件
        for child in self.interaction_frame.winfo_children():
            self.set_widget_state(child, "normal" if enabled else "disabled")
    
    def set_widget_state(self, widget, state):
        """設定元件狀態"""
        try:
            widget.configure(state=state)
        except tk.TclError:
            # 某些元件可能不支援 state 屬性
            pass
        
        # 遞迴處理子元件
        for child in widget.winfo_children():
            self.set_widget_state(child, state)
    
    def reset_to_defaults(self):
        """重設為預設值"""
        self.interaction_enabled_var.set(True)
        self.max_rounds_var.set(3)
        self.include_previous_var.set(True)
        self.batch_size_var.set(100)
        self.on_interaction_enabled_changed()
    
    def save_and_close(self):
        """更新設定並關閉視窗（不保存到檔案）"""
        # 更新設定
        self.settings["interaction_enabled"] = self.interaction_enabled_var.get()
        self.settings["max_rounds"] = self.max_rounds_var.get()
        self.settings["include_previous_response"] = self.include_previous_var.get()
        self.settings["round_delay"] = config.INTERACTION_ROUND_DELAY  # 使用預設值
        self.settings["batch_size"] = self.batch_size_var.get()
        
        # 直接關閉視窗，開始執行腳本
        self.root.destroy()
    
    def run(self):
        """顯示設定介面"""
        self.root.mainloop()
        
        # 如果使用者按 X 取消，回傳 None 表示取消
        if self.cancelled:
            return None
        
        return self.settings

def show_interaction_settings():
    """顯示互動設定介面並回傳設定，如果取消則回傳 None"""
    ui = InteractionSettingsUI()
    return ui.run()

if __name__ == "__main__":
    print("=== Copilot Chat 多輪互動設定 ===")
    print("啟動設定介面...")
    
    try:
        settings = show_interaction_settings()
        if settings is None:
            print("\n設定已取消。")
        else:
            print("\n設定完成！")
            print(f"最終設定: {settings}")
    except Exception as e:
        print(f"設定過程中發生錯誤: {e}")
        input("按 Enter 鍵結束...")
    
    print("設定程式結束。")